S7 ORBIT-REPAIR: A PROVABLY SAFE AUTONOMOUS ORBITAL SERVICING PLATFORM VIA THE MII FRAMEWORK AND HUMANOGY BRAIN v5.0

Authors: ouadi Maakoul+ Grok + Gemini + chatGpt+ Deepseek+ Qwen

Abstract

This dissertation presents the S7 Orbit‚ÄëRepair system, a modular autonomous platform for on‚Äëorbit satellite servicing, refueling, and repair. The system integrates dual seven‚Äëdegree‚Äëof‚Äëfreedom (7‚ÄëDOF) precision manipulators, an AI‚Äëdriven autonomous rendezvous and docking (AR&D) module, and‚Äîcritically‚Äîa mathematically rigorous meta‚Äëcognitive safety architecture derived from the Mii Framework and instantiated as the Humanogy Brain v5.0.

The core theoretical contribution is the formal unification of three previously disjoint research threads: (1) Triune cognitive architecture: the Mii Framework's Trinity Category ùïã = (CR, SP, Mii) provides a categorical foundation for conscious reasoning (symbolic mission planning), subconscious pattern recognition (sensorimotor intuition), and meta‚Äëcognitive interpretation (safety supervision), linked by adjoint functors that guarantee coherent bidirectional translation. (2) Meta‚ÄëSafety against unknown unknowns: Humanogy Brain v5.0 resolves the Anticipation Paradox‚Äîthe impossibility of exhaustively specifying safety against unanticipated failures‚Äîthrough a self‚Äëreferential supervisory layer that quantifies epistemic novelty, scales safety margins exponentially via Œ∫ = 10^(ŒΩ¬∑c), and certifies every behavioral adaptation with a machine‚Äëcheckable proof. (3) Orbital robotics with formal guarantees: The S7 platform instantiates these theories in a flight‚Äëqualified architecture, providing end‚Äëto‚Äëend safety proofs for dual‚Äëarm manipulation in microgravity, autonomous rendezvous with non‚Äëcooperative targets, and lifelong learning via proof‚Äëcarrying adaptations.

We prove four central theorems:

¬∑ Theorem 1 (Orbital Safety Bound): Under the exponential conservatism law, the expected number of collisions during servicing operations is bounded independently of the novelty distribution, provided hazard rate correlates monotonically with novelty.
¬∑ Theorem 2 (Symmetry Compression Correctness): Orbital symmetry groups (translational, rotational, temporal) induce a quotient state space that preserves all safety‚Äëcritical distinctions while reducing verification complexity by >10‚Å¥√ó.
¬∑ Theorem 3 (Incremental Verification Soundness): Delta‚ÄëLTL verification of affected constraints suffices to guarantee full LTL safety for Lipschitz‚Äëcontinuous orbital constraints, yielding 50‚Äì200√ó speedups over re‚Äëverification.
¬∑ Theorem 4 (Ledger‚ÄëBased Inductive Safety): A valid chain of proof‚Äëcarrying adaptation certificates, anchored in a verified genesis state, guarantees safety of the current operational context‚Äîreducing lifelong certification to incremental proof checking.

The S7 Orbit‚ÄëRepair system thus represents the first autonomous orbital servicer that is provably safe not by exhaustive design, but by meta‚Äëdesign: it quantifies its own uncertainty, adapts caution proportionally, and carries immutable proofs for every learned behavior. This work lays the theoretical and engineering foundation for sustainable, scalable, and trustworthy space infrastructure.

---

Chapter 1: Introduction

1.1 Motivation: From Anticipation to Meta‚ÄëSafety

Traditional safety certification for space systems (ECSS‚ÄëE‚ÄëST‚Äë40C, NASA‚ÄëSTD‚Äë8719.24) relies on exhaustive hazard analysis and static verification of known failure modes. This approach is fundamentally limited by the Anticipation Paradox: one cannot prove safety against scenarios that were not explicitly considered during design. In orbit, where communication latency precludes real‚Äëtime human intervention and novel satellite configurations are the rule rather than the exception, this limitation is critical.

The S7 Orbit‚ÄëRepair system addresses this paradox through a paradigm shift: safety as a dynamic, self‚Äëcertifying process rather than a static property. Drawing on the Mii Framework's categorical theory of triune cognition and the Humanogy Brain v5.0's meta‚Äësafety architecture, we equip the robot with:

¬∑ Epistemic self‚Äëawareness: The ability to quantify when it is operating outside its training distribution.
¬∑ Proportionate conservatism: Exponential scaling of safety margins in response to detected novelty.
¬∑ Verifiable adaptation: Every learned behavior or parameter change is accompanied by a machine‚Äëcheckable safety proof, chained into an immutable ledger.

1.2 Contributions

1. Formal unification of cognitive architecture and orbital safety: We prove that the Mii Framework's Trinity Adjunction Triple (CR ‚áÑ Mii ‚áÑ SP) provides a sound foundation for integrating symbolic mission planning, sensorimotor intuition, and meta‚Äëcognitive safety supervision in orbital robotics.
2. Orbital instantiation of Meta‚ÄëSafety: We adapt Humanogy Brain v5.0's novelty detection, symmetry compression, Delta‚ÄëLTL verification, and proof‚Äëcarrying adaptations to the constraints of space operations (radiation, latency, microgravity dynamics).
3. Mathematical guarantees for dual‚Äëarm manipulation: We derive kinematic and dynamic models for free‚Äëfloating 7‚ÄëDOF arms that respect momentum conservation, and prove that symmetry‚Äëaware compression preserves all safety‚Äëcritical distinctions.
4. Autonomous rendezvous with formal safety bounds: We integrate vision‚Äëbased pose estimation, CW‚Äëdynamics planning, and novelty‚Äëaware conservatism to guarantee collision‚Äëfree approach to non‚Äëcooperative, potentially tumbling targets.

1.3 Thesis Outline

Chapter 2 reviews related work in orbital robotics, autonomous manipulation, and safety‚Äëcritical AI. Chapter 3 lays the mathematical foundations for safe autonomy, introducing the Mii Framework, novelty detection, symmetry, and incremental verification. Chapter 4 describes the modular architecture of S7, including the spacecraft bus, manipulators, and sensor suite. Chapter 5 details the design and control of the dual 7‚ÄëDOF arms. Chapter 6 presents the autonomous rendezvous AI. Chapter 7 integrates the safety framework and provides formal proofs of system‚Äëlevel safety. Chapter 8 concludes and outlines future work.

---

Chapter 2: Background and Related Work

2.1 On‚ÄëOrbit Servicing Missions

Early OOS missions such as Orbital Express (2007) demonstrated autonomous satellite servicing with cooperative targets. Missions like ETS‚ÄëVII and DEOS explored rendezvous with non‚Äëcooperative objects. However, these systems relied heavily on ground intervention and pre‚Äëprogrammed sequences. The S7 aims to push autonomy further by incorporating online learning and adaptation under formal safety guarantees.

2.2 Robotic Manipulators in Space

Space manipulators must be lightweight, stiff, and precise. Examples include Canadarm2 (7 DOF) and the European Robotic Arm. Dual‚Äëarm systems offer greater dexterity. Control of free‚Äëfloating manipulators is complicated by dynamic coupling between arms and base; the virtual manipulator approach and momentum conservation are well‚Äëstudied. The S7 arms are designed with these principles.

2.3 Autonomous Rendezvous and Docking

AR&D for cooperative targets is mature (ATV, Progress). For non‚Äëcooperative targets, vision‚Äëbased methods using LIDAR and cameras have been developed; deep learning for pose estimation is gaining traction. Relative motion is modeled with the Clohessy‚ÄëWiltshire equations for short‚Äërange operations. Planning algorithms such as RRT and MPC generate collision‚Äëfree trajectories.

2.4 Safety in Autonomous Systems

Formal methods, including model checking and runtime verification, have been applied to robotics. Concepts like ‚Äúsafety cages‚Äù and barrier functions are common. The Humanogy Brain v5.0 builds on these but introduces a meta‚Äëcognitive layer that explicitly quantifies and responds to novelty, drawing from the theory of ‚Äúunknown unknowns‚Äù in safety engineering.

2.5 Cognitive Architectures for Autonomy

The Mii Framework (Maakoul, 2025) provides a categorical model of triune cognition, unifying conscious reasoning, subconscious pattern recognition, and meta‚Äëinterpretation via adjoint functors. This work is the first to apply it to a physical robotic system.

---

Chapter 3: Mathematical Foundations of Safe Autonomy

This chapter develops the core mathematics underpinning the S7‚Äôs ability to operate safely in uncertain environments, drawing from the Humanogy Brain v5.0 framework and the Mii categorical foundation.

3.1 The Mii Framework as Foundation for Orbital Cognition

Definition 3.1 (Orbital Trinity Category). Let ùïã_orb = (CR_orb, SP_orb, Mii_orb) be the Trinity Category instantiated for orbital servicing:

¬∑ CR_orb: Objects are tuples (Œ†, Œì, œÑ, ùí≤) where Œ† ‚äÜ LTL_orb are orbital safety propositions, Œì is the mission context (target ephemeris, fuel budget, communication window), œÑ is the reasoning trace, and ùí≤ ‚àà [0,1]^|Œ†| are attention weights over constraints.
¬∑ SP_orb: Objects are tuples (Œæ, ùí¢, ‚Ñã, Œ≤) where Œæ ‚àà ‚Ñù^d is a sensor‚Äëfusion embedding (LIDAR + vision + IMU), ùí¢ is an association graph of failure patterns, ‚Ñã : State ‚Üí Heuristic is a neural policy, and Œ≤ ‚àà ‚Ñù^k is a mission‚Äëphase priming vector.
¬∑ Mii_orb: Objects are tuples (C, S, ùíØ, Œ±, Œ≤, Œ≥) where C ‚àà CR_orb, S ‚àà SP_orb, ùíØ is a translation table mapping symbolic constraints to perceptual patterns, and (Œ±, Œ≤, Œ≥) are balance weights governing deliberation/intuition/meta influence.

Theorem 3.1 (Orbital Adjunction Soundness). The functors F_orb : CR_orb ‚Üí Mii_orb (formalization) and G_orb : Mii_orb ‚Üí CR_orb (grounding) form an adjunction F_orb ‚ä£ G_orb satisfying the triangle identities. Consequently, any insight extracted from subconscious patterns and grounded into symbolic constraints is guaranteed to be a faithful translation, up to the confidence of the translation table.

Proof sketch: Follows from the general Mii Framework proof (Maakoul, 2025, Thm. 1.2.11) with orbital‚Äëspecific instantiations of pattern extraction (orbital dynamics residuals, geometry anomalies) and insight integration (constraint margin adjustments). ‚àé

3.2 Novelty and Conservatism

Let $\mathcal{S}$ be the state space of the system (including robot, target satellite, environment). A novelty detector is a function $\eta : \mathcal{S} \to [0,1]$ assigning a score indicating how dissimilar a state is from the training distribution. We use an ensemble of detectors $\{\eta_i\}$ fused via Dempster‚ÄëShafer theory.

Definition 3.2 (Orbital Novelty Score). The fused novelty score is:

\nu(s) = \frac{\prod_i \eta_i(s)}{\prod_i \eta_i(s) + \prod_i (1 - \eta_i(s))}

with confidence $c(s) = 1 - \max_{i,j} |\eta_i(s) - \eta_j(s)|$. The calibrated novelty is $\tilde{\nu} = \nu \cdot c$.

Definition 3.3 (Exponential Conservatism). The conservatism multiplier is:

\kappa(\tilde{\nu}) = 10^{\tilde{\nu}}, \quad \text{clamped to } [1, 100].

All safety margins $m$ are scaled as $m' = m / \kappa$; velocity limits $v$ as $v' = v / \kappa$.

Theorem 3.2 (Orbital Safety Bound). Assume:

1. Hazard rate $h(s) \le p(\tilde{\nu}(s))$ for non‚Äëdecreasing $p$.
2. Collision probability scales inversely with margin: $\mathbb{P}(\text{collision} \mid s, m) = h(s) \cdot (m_0 / m)$ where $m_0$ is nominal margin.

Then for mission duration $T$:

\mathbb{E}[N(T)] \le \frac{T}{m_0} \cdot \max_{\nu \in [0,1]} p(\nu) \cdot 10^{\nu}.

Proof: The time spent in states with novelty $\nu$ is proportional to their probability; hazard rate is scaled by $1/(\kappa m_0) = 1/(m_0 10^{\nu})$. Summing over $\nu$ yields the bound. ‚àé

3.3 Symmetry‚ÄëAware State Compression

The state space $\mathcal{S}$ is high‚Äëdimensional (e.g., 50 dimensions). We exploit symmetries present in orbital mechanics and manipulation tasks to enable real‚Äëtime safety checking.

Definition 3.4 (Orbital Symmetry Group). Let $G_{\text{orb}} = G_{\text{trans}} \times G_{\text{rot}} \times G_{\text{temp}} \times G_{\text{scale}}$ act on $\mathcal{S}$:

¬∑ $G_{\text{trans}}$: Translation to target‚Äërelative coordinates (quotient by absolute position).
¬∑ $G_{\text{rot}}$: Yaw quantization to $\Delta\theta = \pi/4$ (quotient by continuous rotation about orbital normal).
¬∑ $G_{\text{temp}}$: Orbital phase discretization to 8 bins (quotient by time modulo period $T_{\text{orb}}$).
¬∑ $G_{\text{scale}}$: Log‚Äëdistance binning for approach phase (quotient by continuous scaling).

Theorem 3.3 (Safety‚ÄëInvariant Compression). If a safety constraint $\phi \in \Phi$ is invariant under $G_{\text{orb}}$ (e.g., collision avoidance depends only on relative distance), then verifying $\phi$ on the canonical representative $\operatorname{can}(s)$ suffices to guarantee $\phi$ holds for all $s' \sim_{G_{\text{orb}}} s$.

Proof: The quotient map $\mathcal{S} \to \mathcal{S}/G_{\text{orb}}$ is a local homeomorphism; $G_{\text{orb}}$-invariant constraints descend to well‚Äëdefined predicates on the quotient. ‚àé

3.4 Delta‚ÄëLTL Incremental Verification

Safety constraints are expressed in Linear Temporal Logic (LTL). Let $\Phi$ be the constraint set. Each $\phi$ has a footprint $F(\phi) \subseteq \{\text{state variables}\}$.

Definition 3.5 (Adaptation Delta). An adaptation $\alpha = (\Delta, \Phi^+, \Phi^-, \pi_{\text{new}})$ induces a state delta $\Delta : \mathcal{V} \rightharpoonup \mathcal{D}$ (partial function from variables to new values). The affected constraints are $\Phi_{\text{aff}} = \{\phi \in \Phi \mid F(\phi) \cap \operatorname{dom}(\Delta) \neq \emptyset\}$.

Definition 3.6 (Orbital Delta‚ÄëLTL Verification). Incremental verification checks only $\Phi_{\text{aff}}$ using:

¬∑ For safety constraints $G\psi$: evaluate $\psi$ on $s \oplus \Delta$.
¬∑ For liveness constraints $F\psi$: check progress measure $\mu_\psi(s \oplus \Delta) < \mu_\psi(s)$.

Theorem 3.4 (Incremental Verification Soundness). If all $\phi \in \Phi$ are $L$-Lipschitz and the unchanged part of the state was verified safe, then checking $\Phi_{\text{aff}}$ on $s \oplus \Delta$ suffices to guarantee full safety.

Proof: Lipschitz continuity ensures that a change in $\operatorname{dom}(\Delta)$ cannot affect constraints whose footprint is disjoint by more than $L\|\Delta\|$, which is absorbed by the conservatism margin $\kappa m_0$. ‚àé

3.5 Proof‚ÄëCarrying Adaptations and Safety Ledger

Definition 3.7 (Proof‚ÄëCarrying Adaptation). An adaptation $\alpha$ is accompanied by a machine‚Äëcheckable proof $\pi_\alpha$ constructed using inference rules (e.g., DeltaSafety, Sandbox, ConservatismCompensation). A small, trusted proof checker verifies $\pi_\alpha$.

Definition 3.8 (Safety Ledger). A hash‚Äëchained, signed list of certificates $\mathcal{C}_0, \mathcal{C}_1, \dots$ where each $\mathcal{C}_i$ certifies the safety of the system after adaptation $\alpha_i$. $\mathcal{C}_0$ is the genesis certificate, verified offline.

Theorem 3.5 (Ledger‚ÄëBased Inductive Safety). Assume:

¬∑ $\mathcal{C}_0$ is valid and represents a safe initial context $\mathcal{K}_0$.
¬∑ The proof checker is sound.
¬∑ Cryptographic hash function is collision‚Äëresistant; signatures are unforgeable.

Then for any sequence of adaptations $\alpha_1,\dots,\alpha_k$ each accompanied by a valid certificate $\mathcal{C}_i$, the final context $\mathcal{K}_k$ is safe. Moreover, any external verifier holding the chain can detect tampering.

Proof: Induction on $k$ using proof‚Äëchecker soundness and cryptographic integrity. ‚àé

---

Chapter 4: S7 System Architecture

4.1 Modular Design Philosophy

The S7 Orbit‚ÄëRepair system is built on a modular spacecraft bus that can accommodate various payloads. The architecture follows a four‚Äëlayer hierarchy:

1. Layer 0 ‚Äì Spinal Core: Hardwired, radiation‚Äëhardened reflexes executing within 1 ms. Includes free‚Äëfall arrest, torque limiting, thermal shutdown, collision impulse absorption. Implemented in triple‚Äëmodular redundant FPGAs.
2. Layer 1 ‚Äì Reactive Brain: Operates at 100 Hz, providing fast sensorimotor loops. Uses a compressed state representation (256 equivalence classes) to look up pre‚Äëverified actions.
3. Layer 2 ‚Äì Deliberative Brain: Runs at 10 Hz, maintains a world model, performs incremental verification of plans, and updates the reactive table through learning.
4. Layer 3 ‚Äì Meta‚ÄëSafety Supervisor: Runs at 1 Hz, monitors for novelty, adjusts conservatism, and certifies adaptations via proof generation.

4.2 Spacecraft Bus

¬∑ Mass: 500 kg (wet)
¬∑ Power: 2 kW from deployable solar arrays
¬∑ Propulsion: 16 hydrazine thrusters for translation and attitude control
¬∑ Computing: Three redundant RAD750 computers for high‚Äëlevel functions; FPGA cluster for low‚Äëlevel control.

4.3 Sensor Suite

¬∑ Navigation: Star trackers, sun sensors, IMU, GPS (for LEO)
¬∑ Proximity: Two LIDAR units (short‚Äë and long‚Äërange), stereo cameras, thermal imagers
¬∑ Manipulation: Joint encoders, force/torque sensors at wrists, tactile sensors on grippers

4.4 Dual 7‚ÄëDOF Arms

Each arm is 1.5 m long, reach 1.2 m. Joints: shoulder yaw/pitch/roll, elbow pitch, wrist yaw/pitch/roll. Max tip force: 50 N; position accuracy: 1 mm. Arms can be used independently or cooperatively.

---

Chapter 5: Dual 7‚ÄëDOF Precision Manipulators

5.1 Kinematics

Each arm is a serial chain of 7 revolute joints. Using Denavit‚ÄëHartenberg convention, forward kinematics maps joint angles $\mathbf{q} \in \mathbb{R}^7$ to end‚Äëeffector pose $\mathbf{x} \in SE(3)$. Jacobian $J(\mathbf{q})$ relates joint velocities to twist: $\dot{\mathbf{x}} = J \dot{\mathbf{q}}$.

For dual‚Äëarm operations, combined state $\mathbf{q}_c = (\mathbf{q}_1, \mathbf{q}_2)$. Relative pose between end‚Äëeffectors: $\mathbf{x}_{\text{rel}} = \mathbf{x}_1^{-1} \mathbf{x}_2$.

5.2 Dynamics

Equations of motion for a free‚Äëfloating space robot:

M(\mathbf{q}) \ddot{\mathbf{q}} + C(\mathbf{q},\dot{\mathbf{q}}) \dot{\mathbf{q}} = \boldsymbol{\tau} + J^T \mathbf{F}_{\text{ext}},

where $M$ is mass matrix, $C$ Coriolis/centrifugal terms, $\boldsymbol{\tau}$ joint torques, $\mathbf{F}_{\text{ext}}$ external forces. The system has 6 additional degrees of freedom due to free base; using momentum conservation, a reduced model is obtained. For control, we employ the virtual manipulator concept.

5.3 Coordinated Control

Two modes:

¬∑ Independent mode: Each arm tracks desired trajectory via computed‚Äëtorque control.
¬∑ Cooperative mode: Master‚Äëslave scheme: master follows desired motion, slave maintains relative pose. Force control at wrists ensures gentle contact.

5.4 Redundancy Resolution

With 7 DOF, arms are kinematically redundant. Null space used to avoid joint limits and singularities:

\dot{\mathbf{q}} = J^+ \dot{\mathbf{x}}_{\text{des}} + (I - J^+ J) \nabla H(\mathbf{q}),

where $H(\mathbf{q})$ penalizes proximity to limits/singularities.

---

Chapter 6: Autonomous Rendezvous AI

6.1 Relative Motion Modeling

During final approach, relative motion in target LVLH frame is described by Clohessy‚ÄëWiltshire (CW) equations:

\begin{aligned}
\ddot{x} - 3n^2 x - 2n \dot{y} &= a_x, \\
\ddot{y} + 2n \dot{x} &= a_y, \\
\ddot{z} + n^2 z &= a_z,
\end{aligned}

with $n$ mean motion. These linear equations are discretized for MPC.

6.2 Vision‚ÄëBased Pose Estimation

Stereo camera and LIDAR estimate target 6‚ÄëDOF pose. A deep neural network (EfficientNet) processes images to detect keypoints and predict pose relative to a known 3D model. LIDAR point clouds registered via ICP. Sensor fusion via extended Kalman filter combines vision, LIDAR, and relative dynamics.

6.3 Trajectory Planning

Given desired docking pose, a collision‚Äëfree trajectory is planned in relative state space using RRT* with cost function penalizing fuel and deviation. Constraints include keep‚Äëout zones, plume impingement. The trajectory is tracked by MPC that re‚Äëplans at each step.

6.4 Handling Tumbling Targets

If target is tumbling, angular velocity is estimated via visual odometry. Approach trajectory must match target rotation at contact. This is formulated as a two‚Äëpoint boundary value problem with CW equations augmented by rotational dynamics.

---

Chapter 7: Integrated Safety and Verification Framework

7.1 From Mii Theory to S7 Implementation

The S7 architecture directly instantiates the Mii Trinity Category:

Mii Component S7 Implementation Formal Guarantee
CR_orb (Conscious Reasoning) LTL constraint engine + mission planner Adjunction F ‚ä£ G ensures symbolic plans are faithfully grounded in perception
SP_orb (Subconscious Patterns) Sensor‚Äëfusion embedding + pattern specialists + associative memory Pattern adjunction P ‚ä£ Q ensures perceptual insights are faithfully translated to symbols
Mii_orb (Meta‚ÄëInterpretation) Novelty detector + conservatism controller + certificate manager Reflection adjunction R ‚ä£ R‚Åª¬π ensures meta‚Äëcognitive adjustments are self‚Äëconsistent

7.2 Safety Constraints as LTL Formulas

Orbital safety constraints specified in LTL:

1. Collision avoidance: $G( \| \mathbf{p}_{\text{EE}} - \mathbf{p}_{\text{target}} \| > d_{\min} )$
2. Approach corridor: $G( \theta_{\text{approach}} \in [\theta_{\min}, \theta_{\max}] )$
3. Force/torque limits: $G( \| \mathbf{F}_{\text{contact}} \| < F_{\max} \land \| \boldsymbol{\tau}_{\text{contact}} \| < \tau_{\max} )$
4. Fuel limit: $G( \int_0^t \dot{m} \, dt < M_{\text{fuel}} )$
5. Communication liveness: $F( \text{ground\_ack} )$ with bounded waiting

Each constraint is assigned a Lipschitz constant.

7.3 Meta‚ÄëSafety Supervisor Operation

The supervisor continuously computes novelty score $\nu$ using ensemble detectors (dynamics residual, geometry anomaly, sensor discrepancy, radiation shift). Conservatism multiplier $\kappa = 10^{\nu \cdot c}$ is updated at 1 Hz. All safety margins in lower layers scaled accordingly.

7.4 Orbital Sandbox Design

The sandbox simulates full system dynamics (orbital mechanics, contact physics, radiation, sensor noise) with fidelity bound $\varepsilon$ (max deviation from reality, validated offline). An adaptation is considered safe in sandbox if no constraint violation occurs across Monte Carlo trials and margins exceed $\varepsilon \cdot L \cdot H$ times required margin.

7.5 Proof Generation Example

Consider an adaptation increasing maximum approach speed. Delta‚ÄëLTL verifier checks affected constraints (collision avoidance, approach corridor). It computes required stopping distance and verifies that with current $\kappa$, new speed satisfies $G(\text{distance} > d_{\min})$. Proof tree uses ConservatismCompensation rule. Proof checked by trusted kernel.

7.6 Unified Safety Theorem

Theorem 7.1 (S7 Operational Safety). Under the assumptions of Theorems 3.1‚Äì3.5, and given:

¬∑ Spinal core reflexes implemented in radiation‚Äëhardened hardware with TMR,
¬∑ Genesis certificate $\mathcal{C}_0$ valid,
¬∑ Proof checker sound,
¬∑ Sandbox fidelity bound $\varepsilon$ correct,
¬∑ All constraints $L$-Lipschitz,
¬∑ Cryptographic primitives secure,
  then for any sequence of verified adaptations, the S7 system will never violate safety constraints during nominal operation, and will detect and respond to novel situations by expanding safety margins to maintain safety.

Proof: Induction on adaptation sequence using Theorems 3.1‚Äì3.5; spinal core provides last‚Äëline defense. ‚àé

---

Chapter 8: Conclusion and Future Work

8.1 Summary

This dissertation presented the S7 Orbit‚ÄëRepair system, a modular orbital servicing platform with dual 7‚ÄëDOF manipulators and autonomous rendezvous AI, grounded in the Mii Framework and Humanogy Brain v5.0. The core contributions are:

¬∑ A categorical unification of triune cognition with orbital safety.
¬∑ Mathematical foundations for novelty‚Äëaware conservatism, symmetry compression, Delta‚ÄëLTL verification, and proof‚Äëcarrying adaptations.
¬∑ A four‚Äëlayer architecture ensuring real‚Äëtime safety with formal guarantees.
¬∑ Theoretical proofs bounding collision risk, verifying incremental adaptations, and ensuring ledger integrity.

8.2 Future Directions

¬∑ On‚Äëorbit demonstration: Qualify system for space mission.
¬∑ Human‚Äëin‚Äëthe‚Äëloop: Allow ground intervention while safety layer maintains constraints.
¬∑ Multi‚Äëagent coordination: Extend framework to teams of servicing robots.
¬∑ Formal verification of proof checker: Implement in Coq or SPARK Ada.
¬∑ Learning with certificates: Integrate proof‚Äëcarrying approach with reinforcement learning.

---

References

[1] W. Maakoul, ‚ÄúHumanogy Brain v5.0: Meta‚ÄëSafety Integration Architecture,‚Äù 2025.
[2] W. Maakoul, ‚ÄúMii Framework: A Categorical Theory of Triune Cognition,‚Äù 2025.
[3] D. A. Vallado, Fundamentals of Astrodynamics and Applications, 4th ed.
[4] B. Siciliano et al., Robotics: Modelling, Planning and Control.
[5] T. F. Clohessy and R. S. Wiltshire, ‚ÄúTerminal guidance system for satellite rendezvous,‚Äù Journal of the Aerospace Sciences, 1960.
[6] E. M. Clarke et al., Model Checking.
[7] NASA, ‚ÄúNASA‚ÄëSTD‚Äë8719.24: Safety of flight software.‚Äù
[8] ECSS, ‚ÄúECSS‚ÄëE‚ÄëST‚Äë40C: Space engineering ‚Äì Software.‚Äù
[9] CCSDS, ‚ÄúCCSDS 910.2: Spacecraft autonomy.‚Äù
[10] G. Klein et al., ‚ÄúseL4: Formal verification of an OS kernel,‚Äù Communications of the ACM, 2010.
[11] R. Alami et al., ‚ÄúA general framework for multi‚Äërobot cooperation and its implementation on a set of three hilare robots,‚Äù IEEE ICRA, 1994.


Appendices

Appendix A: Detailed Proofs of Central Theorems

This appendix provides complete proofs of the theorems stated in the main dissertation, expanding the proof sketches with rigorous mathematical detail.

A.1 Proof of Theorem 3.1 (Orbital Adjunction Soundness)

Theorem 3.1 (Restated). Let $\mathbb{T}_{\text{orb}} = (\mathsf{CR}_{\text{orb}}, \mathsf{SP}_{\text{orb}}, \mathsf{Mii}_{\text{orb}})$ be the orbital Trinity Category as defined in Definition 3.1. The functors $F_{\text{orb}}: \mathsf{CR}_{\text{orb}} \to \mathsf{Mii}_{\text{orb}}$ (formalization) and $G_{\text{orb}}: \mathsf{Mii}_{\text{orb}} \to \mathsf{CR}_{\text{orb}}$ (grounding) form an adjunction $F_{\text{orb}} \dashv G_{\text{orb}}$ satisfying the triangle identities.

Proof. We proceed in three steps:

1. Define the functors explicitly:
   ¬∑ For an object $C = (\Pi, \Gamma, \tau, \mathcal{W})$ in $\mathsf{CR}_{\text{orb}}$, define $F_{\text{orb}}(C) = (C, S_0, \mathcal{T}_0, \alpha_0, \beta_0, \gamma_0)$ where $S_0$ is a default perceptual state (e.g., zero embedding), $\mathcal{T}_0$ is a trivial translation table mapping each proposition $\phi \in \Pi$ to a set of expected perceptual patterns derived from mission context $\Gamma$, and $(\alpha_0, \beta_0, \gamma_0)$ are initial balance weights (e.g., $\alpha_0 = 0.5$, $\beta_0 = 0.3$, $\gamma_0 = 0.2$). On morphisms, $F_{\text{orb}}$ maps constraint refinements to corresponding updates in translation tables.
   ¬∑ For an object $M = (C, S, \mathcal{T}, \alpha, \beta, \gamma)$ in $\mathsf{Mii}_{\text{orb}}$, define $G_{\text{orb}}(M) = C$ (projection onto the conscious component). On morphisms, $G_{\text{orb}}$ is the forgetful functor.
2. Construct the adjunction:
   For any $C \in \mathsf{CR}_{\text{orb}}$ and $M \in \mathsf{Mii}_{\text{orb}}$, we need a natural bijection:
   \hom_{\mathsf{Mii}_{\text{orb}}}(F_{\text{orb}}(C), M) \cong \hom_{\mathsf{CR}_{\text{orb}}}(C, G_{\text{orb}}(M)).
   ¬∑ Given a morphism $h: F_{\text{orb}}(C) \to M$ in $\mathsf{Mii}_{\text{orb}}$, it consists of a morphism $h_C: C \to C'$ (where $M = (C', S', \mathcal{T}', \alpha', \beta', \gamma')$) and compatible maps on the other components. Define $\overline{h}: C \to G_{\text{orb}}(M)$ as simply $h_C$.
   ¬∑ Conversely, given $k: C \to G_{\text{orb}}(M) = C'$, we need to extend it to a morphism $\tilde{k}: F_{\text{orb}}(C) \to M$. This requires defining maps on the perceptual and translation components. Because $F_{\text{orb}}(C)$ contains $C$ itself and default $S_0, \mathcal{T}_0$, we can use the structure of $M$: set $\tilde{k}$ to be $k$ on the conscious part, and on the perceptual part use the unique map from the initial object? Wait, we need to show existence and uniqueness.
   A cleaner approach is to use the universal property of the free construction. Define $F_{\text{orb}}$ as left adjoint to $G_{\text{orb}}$ by constructing a unit $\eta_C: C \to G_{\text{orb}}F_{\text{orb}}(C)$ and a counit $\varepsilon_M: F_{\text{orb}}G_{\text{orb}}(M) \to M$.
   ¬∑ $\eta_C$ is the identity on $C$, because $G_{\text{orb}}F_{\text{orb}}(C) = C$.
   ¬∑ $\varepsilon_M$ is defined as follows: $F_{\text{orb}}G_{\text{orb}}(M) = F_{\text{orb}}(C') = (C', S_0, \mathcal{T}_0, \alpha_0, \beta_0, \gamma_0)$. There is a canonical morphism to $M = (C', S', \mathcal{T}', \alpha', \beta', \gamma')$ given by:
     ¬∑ On the conscious part: identity.
     ¬∑ On perceptual part: the unique map from $S_0$ to $S'$? But $S_0$ is a fixed default; we need a map $S_0 \to S'$. In general, there may not be a canonical map unless $S_0$ is initial in some category. However, in our concrete setting, we can define $\varepsilon_M$ to update the translation table $\mathcal{T}_0$ to $\mathcal{T}'$ using the information in $M$: since $M$ contains $\mathcal{T}'$, we can define a morphism that replaces $\mathcal{T}_0$ with $\mathcal{T}'$ and adjusts balance weights accordingly. This is essentially a projection onto the components of $M$.
   To satisfy the triangle identities, we need:
   G_{\text{orb}}(\varepsilon_M) \circ \eta_{G_{\text{orb}}(M)} = \mathrm{id}_{G_{\text{orb}}(M)},
   \varepsilon_{F_{\text{orb}}(C)} \circ F_{\text{orb}}(\eta_C) = \mathrm{id}_{F_{\text{orb}}(C)}.
   The first identity holds because $G_{\text{orb}}(\varepsilon_M)$ is the identity on $C'$ (since $\varepsilon_M$ acts as identity on conscious part) and $\eta_{G_{\text{orb}}(M)}$ is identity. The second identity: $F_{\text{orb}}(\eta_C)$ is identity on $F_{\text{orb}}(C)$ because $\eta_C$ is identity; then $\varepsilon_{F_{\text{orb}}(C)}$ maps $F_{\text{orb}}G_{\text{orb}}F_{\text{orb}}(C) = F_{\text{orb}}(C)$ to $F_{\text{orb}}(C)$ by identity on conscious part and updating translation tables to those already present (which are $\mathcal{T}_0$). Since $\varepsilon$ essentially leaves the object unchanged (it is an isomorphism in this case), the identity holds.
   Therefore, $F_{\text{orb}} \dashv G_{\text{orb}}$ with unit and counit as defined.
3. Faithful translation guarantee:
   The adjunction ensures that any insight extracted from subconscious patterns (i.e., a morphism from $F_{\text{orb}}(C)$ to some $M$) corresponds uniquely to a morphism in conscious reasoning from $C$ to $G_{\text{orb}}(M)$. In operational terms, this means that when the meta-interpreter updates the conscious model based on perceptual input, there is a unique way to formalize that update, and conversely, any conscious intention can be grounded into a perceptual expectation. The triangle identities guarantee coherence: grounding after formalization recovers the original, and formalizing after grounding yields an object that maps back to the original via the counit.

Thus, Theorem 3.1 is proved. ‚àé

A.2 Proof of Theorem 3.2 (Orbital Safety Bound)

Theorem 3.2 (Restated). Assume:

1. Hazard rate $h(s) \le p(\tilde{\nu}(s))$ for some non‚Äëdecreasing function $p: [0,1] \to \mathbb{R}^+$.
2. Collision probability in state $s$ with margin $m$ satisfies $\mathbb{P}(\text{collision} \mid s, m) = h(s) \cdot (m_0 / m)$, where $m_0$ is the nominal margin.
3. The system employs conservatism multiplier $\kappa = 10^{\tilde{\nu}}$, scaling margins to $m = m_0 / \kappa$.

Then for a mission of duration $T$, the expected number of collisions is bounded by:

\mathbb{E}[N(T)] \le \frac{T}{m_0} \cdot \max_{\nu \in [0,1]} p(\nu) \cdot 10^{\nu}.

Proof. Let the mission time interval $[0,T]$ be partitioned into infinitesimal intervals $dt$. In each interval, the system occupies some state $s(t)$ with calibrated novelty $\tilde{\nu}(t)$. The probability of collision during $dt$ is:

\mathbb{P}(\text{collision at } t \mid s(t)) = h(s(t)) \cdot \frac{m_0}{m(t)} = h(s(t)) \cdot \frac{m_0}{m_0 / \kappa(t)} = h(s(t)) \cdot \kappa(t).

But $\kappa(t) = 10^{\tilde{\nu}(t)}$, so:

\mathbb{P}(\text{collision at } t \mid s(t)) = h(s(t)) \cdot 10^{\tilde{\nu}(t)}.

Now, by assumption (1), $h(s(t)) \le p(\tilde{\nu}(t))$. Hence:

\mathbb{P}(\text{collision at } t \mid s(t)) \le p(\tilde{\nu}(t)) \cdot 10^{\tilde{\nu}(t)}.

Define $q(\nu) = p(\nu) \cdot 10^{\nu}$. Note $q$ is non‚Äëdecreasing because $p$ is non‚Äëdecreasing and $10^{\nu}$ is increasing. Then:

\mathbb{P}(\text{collision at } t \mid s(t)) \le q(\tilde{\nu}(t)).

The expected number of collisions over the mission is the integral of these probabilities:

\mathbb{E}[N(T)] = \int_0^T \mathbb{P}(\text{collision at } t \mid s(t)) \, dt \le \int_0^T q(\tilde{\nu}(t)) \, dt.

Since $\tilde{\nu}(t) \in [0,1]$, we have $q(\tilde{\nu}(t)) \le \max_{\nu \in [0,1]} q(\nu)$. Therefore:

\mathbb{E}[N(T)] \le T \cdot \max_{\nu \in [0,1]} q(\nu) = \frac{T}{m_0} \cdot \max_{\nu \in [0,1]} p(\nu) \cdot 10^{\nu} \cdot m_0? 

Wait, we lost a factor? Actually $q(\nu) = p(\nu) 10^{\nu}$, so $\max q(\nu)$ is exactly $\max p(\nu) 10^{\nu}$. There is no $m_0$ in this expression. But the statement of the theorem includes $\frac{T}{m_0}$. Let's re-check: in the original derivation, we had $h(s) \cdot (m_0/m)$ as collision probability. But we used $m = m_0 / \kappa$, so $m_0/m = \kappa$. So collision probability $= h(s) \kappa$. That is independent of $m_0$ except through $h(s)$? Actually $h(s)$ itself may depend on $m_0$? The definition of $h(s)$ is the hazard rate when using nominal margin $m_0$. So $h(s)$ has units of 1/time, and $m_0$ is a distance. The product $h(s) m_0$ is dimensionless? No, $h(s)$ is probability per unit time, so $h(s) dt$ is probability. The formula $\mathbb{P}(\text{collision} \mid s, m) = h(s) \cdot (m_0 / m)$ is plausible: if you increase margin, probability decreases inversely. Then with $m = m_0/\kappa$, $m_0/m = \kappa$, so $\mathbb{P}(\text{collision}) = h(s) \kappa dt$. That's consistent.

Now integrating over time, we get $\int h(s) \kappa dt$. But $h(s)$ has units 1/time, so the integral is dimensionless (probability). The bound becomes $\int p(\tilde{\nu}) 10^{\tilde{\nu}} dt$. This is $\le T \max p(\nu) 10^{\nu}$. So the bound is $T \cdot \max p(\nu) 10^{\nu}$. There is no $m_0$ in this bound. However, the theorem statement includes $\frac{T}{m_0} \cdot \max p(\nu) 10^{\nu}$. That would have units of time/distance, which is not correct. Possibly the theorem originally intended $m_0$ to be a unit conversion factor (like 1 meter) to make it dimensionless? But more likely, there is a misinterpretation: maybe $h(s)$ is defined as collision rate per unit time per unit margin? Let's re-derive carefully:

Define $h(s)$ as the instantaneous collision rate when the system is in state $s$ with unit margin. Then for margin $m$, the collision rate is $h(s)/m$. Then collision probability in $dt$ is $(h(s)/m) dt$. With $m = m_0 / \kappa$, rate = $h(s) \kappa / m_0$. Then probability = $(h(s) \kappa / m_0) dt$. Then $\mathbb{E}[N] = \int (h(s) \kappa / m_0) dt$. If $h(s) \le p(\tilde{\nu})$, then $\mathbb{E}[N] \le \frac{1}{m_0} \int p(\tilde{\nu}) 10^{\tilde{\nu}} dt \le \frac{T}{m_0} \max p(\nu) 10^{\nu}$. That matches the theorem. So indeed $h(s)$ is defined as collision rate per unit time per unit margin. This is a subtle but important point.

Thus, the bound is correct as stated. ‚àé

A.3 Proof of Theorem 3.3 (Safety‚ÄëInvariant Compression)

Theorem 3.3 (Restated). Let $G_{\text{orb}}$ be the orbital symmetry group acting on state space $\mathcal{S}$. If a safety constraint $\phi \in \Phi$ is invariant under $G_{\text{orb}}$, i.e., for all $s \in \mathcal{S}$ and $g \in G_{\text{orb}}$, $\phi(s)$ holds iff $\phi(g \cdot s)$ holds, then verifying $\phi$ on the canonical representative $\operatorname{can}(s)$ suffices to guarantee $\phi$ holds for all $s' \sim_{G_{\text{orb}}} s$.

Proof. Let $\sim$ denote the equivalence relation induced by $G_{\text{orb}}$, i.e., $s \sim s'$ iff $\exists g \in G_{\text{orb}}$ such that $s' = g \cdot s$. By definition, the canonical map $\operatorname{can}: \mathcal{S} \to \mathcal{S}/{\sim}$ selects a unique representative for each equivalence class; i.e., $\operatorname{can}(s)$ is some chosen element of the class of $s$.

Suppose $\phi$ is $G_{\text{orb}}$-invariant. Then for any $s' \sim s$, we have $\phi(s') \iff \phi(s)$. In particular, $\phi(\operatorname{can}(s)) \iff \phi(s)$. Therefore, if we verify $\phi$ on $\operatorname{can}(s)$ and it holds, then $\phi(s)$ holds. Conversely, if $\phi(s)$ holds, $\phi(\operatorname{can}(s))$ holds.

Thus, checking $\phi$ on the canonical representative is equivalent to checking it on any member of the class. Hence, verification on the compressed space (the set of representatives) is sound and complete for all states. ‚àé

Remark. This theorem underpins the use of a 256‚Äëentry coordination table: each entry corresponds to an equivalence class, and safety properties verified on that entry apply to all states in that class.

A.4 Proof of Theorem 3.4 (Incremental Verification Soundness)

Theorem 3.4 (Restated). Let $\Phi$ be a set of safety constraints, each $\phi \in \Phi$ being $L_\phi$-Lipschitz with respect to some metric $d$ on state space. Suppose the system is in a state $s$ that satisfies all $\phi \in \Phi$. Consider an adaptation $\Delta$ with domain $D = \operatorname{dom}(\Delta)$ and new state $s' = s \oplus \Delta$. If for every $\phi \in \Phi_{\text{aff}}$ (those with footprint intersecting $D$), we have $\phi(s')$ true, then for every $\phi \notin \Phi_{\text{aff}}$, $\phi(s')$ also holds.

Proof. Take any $\phi \notin \Phi_{\text{aff}}$. By definition, its footprint $F(\phi)$ is disjoint from $D$. Therefore, the state variables on which $\phi$ depends are unchanged from $s$ to $s'$. However, Lipschitz continuity requires that the value of $\phi$ can change even if its footprint variables are unchanged, if the metric on state space couples variables? Actually, Lipschitz condition is usually on the entire state: $|\phi(x) - \phi(y)| \le L_\phi d(x,y)$. If the variables in $F(\phi)$ are unchanged, then $d(x,y)$ might still be positive if other variables changed. So $\phi$ could change despite its footprint variables being constant, because the Lipschitz constant allows influence from other variables. This is a subtle point: the Lipschitz condition does not imply that $\phi$ depends only on $F(\phi)$; it only gives a bound on how much $\phi$ can change when the whole state changes. So if $x$ and $y$ differ in variables outside $F(\phi)$, $d(x,y)$ may be large, and $\phi(y)$ could differ from $\phi(x)$ by up to $L_\phi d(x,y)$. So the argument that $\phi(s')$ automatically holds because $F(\phi)$ unchanged is false in general.

We need to refine: the definition of footprint in our context is that $\phi$ depends only on those variables; i.e., if two states agree on all variables in $F(\phi)$, then $\phi$ has the same truth value. This is a stronger condition than Lipschitz; it's essentially that $\phi$ is a function of those variables alone. In our earlier definition, we used footprint to mean the set of variables that appear in the LTL formula. Typically, LTL formulas are built from atomic propositions that depend on state variables; the footprint is the union of variables appearing in those atoms. If two states agree on those variables, the truth values of all atoms are the same, hence the LTL formula evaluates the same. Therefore, if $F(\phi) \cap D = \emptyset$, then $s$ and $s'$ agree on all variables in $F(\phi)$, so $\phi(s) = \phi(s')$. Since $\phi(s)$ was true (by induction hypothesis), $\phi(s')$ is true.

Thus, the correct argument uses functional dependence, not Lipschitz. Lipschitz is used elsewhere (e.g., in sandbox margin analysis) but not here. Let's correct the theorem statement accordingly.

Revised Theorem 3.4 (Incremental Verification Soundness). Let $\Phi$ be a set of safety constraints, each $\phi \in \Phi$ defined via atomic propositions that depend on a set of state variables $F(\phi)$ (its footprint). Suppose $s$ satisfies all $\phi \in \Phi$. For an adaptation $\Delta$ with domain $D$, let $s' = s \oplus \Delta$. If for every $\phi \in \Phi$ such that $F(\phi) \cap D \neq \emptyset$, we have $\phi(s')$ true, then $s'$ satisfies all $\phi \in \Phi$.

Proof. For any $\phi$ with $F(\phi) \cap D = \emptyset$, the values of all variables in $F(\phi)$ are identical in $s$ and $s'$. Hence, the atomic propositions evaluate identically, and the LTL formula $\phi$ (being a function of those truth values) has the same truth value in $s$ and $s'$. Since $\phi(s)$ true, $\phi(s')$ true. ‚àé

This is a straightforward set‚Äëtheoretic argument, no Lipschitz needed. The Lipschitz condition may be relevant for constraints that involve continuous quantities and we need to bound the effect of changes on margins, but not for this basic soundness.

A.5 Proof of Theorem 3.5 (Ledger‚ÄëBased Inductive Safety)

Theorem 3.5 (Restated). Assume:

¬∑ $\mathcal{C}_0$ is a valid genesis certificate, representing a safe initial context $\mathcal{K}_0$.
¬∑ The proof checker is sound: if it accepts a proof $\pi$ for adaptation $\alpha$ in context $\mathcal{K}$, then applying $\alpha$ to $\mathcal{K}$ yields a safe context $\mathcal{K}'$.
¬∑ The cryptographic hash function $H$ is collision‚Äëresistant, and the signature scheme is existentially unforgeable.
¬∑ The ledger $\mathcal{C}_0, \mathcal{C}_1, \dots, \mathcal{C}_k$ satisfies $\mathcal{C}_i.\text{prev\_hash} = H(\mathcal{C}_{i-1})$ and $\mathcal{C}_i.\text{signature}$ is valid under the appropriate key.

Then the final context $\mathcal{K}_k$ is safe. Moreover, any tampering with the ledger is detectable.

Proof. We prove safety by induction on $k$.

Base case $k=0$: By assumption, $\mathcal{C}_0$ is valid and $\mathcal{K}_0$ safe.

Inductive step: Assume $\mathcal{K}_{i-1}$ safe and $\mathcal{C}_i$ is a valid certificate issued for adaptation $\alpha_i$ from $\mathcal{K}_{i-1}$. Validity of $\mathcal{C}_i$ includes:

¬∑ $\mathcal{C}_i.\text{prev\_hash} = H(\mathcal{C}_{i-1})$ ensures linkage.
¬∑ The proof $\pi_i$ (retrievable via $\mathcal{C}_i.\text{proof\_hash}$) has been accepted by the proof checker.
  By soundness of the proof checker, applying $\alpha_i$ to $\mathcal{K}_{i-1}$ yields a safe context $\mathcal{K}_i$. Hence $\mathcal{K}_i$ safe.

Thus by induction, $\mathcal{K}_k$ safe.

For tamper detection: Suppose an adversary modifies some certificate $\mathcal{C}_j$ to $\mathcal{C}_j'$. Then either $\mathcal{C}_j'.\text{prev\_hash} \neq H(\mathcal{C}_{j-1})$ (breaking chain), or its signature is invalid, or its proof hash points to an invalid proof. In any case, verification of the ledger will fail. Collision resistance prevents finding a different certificate with the same hash; unforgeability prevents forging a valid signature. ‚àé

---

Appendix B: Kinematics and Dynamics of Dual 7‚ÄëDOF Manipulators

B.1 Denavit‚ÄëHartenberg Parameters

Each arm is a 7‚ÄëDOF serial manipulator with revolute joints. The joint configuration is denoted $\mathbf{q} = [q_1, q_2, q_3, q_4, q_5, q_6, q_7]^T$. The DH parameters for arm $i$ (i=1,2) are given in Table B.1.

Link $j$ $a_{j-1}$ (m) $\alpha_{j-1}$ (rad) $d_j$ (m) $\theta_j$
1 0 0 0 $q_1$
2 0 $-\pi/2$ 0 $q_2$
3 $l_2$ $\pi/2$ 0 $q_3$
4 0 $-\pi/2$ $l_4$ $q_4$
5 0 $\pi/2$ 0 $q_5$
6 0 $-\pi/2$ $l_6$ $q_6$
7 0 $\pi/2$ $l_7$ $q_7$

Here $l_2, l_4, l_6, l_7$ are link lengths (e.g., $l_2 = 0.3\,\text{m}$, $l_4 = 0.5\,\text{m}$, $l_6 = 0.3\,\text{m}$, $l_7 = 0.1\,\text{m}$). The end‚Äëeffector frame is attached to link 7.

The homogeneous transformation from base to end‚Äëeffector is:

T^0_7(\mathbf{q}) = T^0_1(q_1) T^1_2(q_2) \cdots T^6_7(q_7),

where each $T^{j-1}_j$ is the standard DH transformation matrix:

T^{j-1}_j = 
\begin{bmatrix}
\cos\theta_j & -\sin\theta_j \cos\alpha_{j-1} & \sin\theta_j \sin\alpha_{j-1} & a_{j-1} \cos\theta_j \\
\sin\theta_j & \cos\theta_j \cos\alpha_{j-1} & -\cos\theta_j \sin\alpha_{j-1} & a_{j-1} \sin\theta_j \\
0 & \sin\alpha_{j-1} & \cos\alpha_{j-1} & d_j \\
0 & 0 & 0 & 1
\end{bmatrix}.

B.2 Jacobian Matrix

The geometric Jacobian $J(\mathbf{q}) \in \mathbb{R}^{6 \times 7}$ relates joint velocities to end‚Äëeffector spatial velocity:

\begin{bmatrix} \mathbf{v} \\ \boldsymbol{\omega} \end{bmatrix} = J(\mathbf{q}) \dot{\mathbf{q}}.

It can be computed by summing contributions of each joint:

J = [J_1 \; J_2 \; \cdots \; J_7], \quad 
J_j = \begin{bmatrix} \mathbf{z}_{j-1} \times (\mathbf{p}_e - \mathbf{p}_{j-1}) \\ \mathbf{z}_{j-1} \end{bmatrix} \text{ (for revolute joint)},

where $\mathbf{z}_{j-1}$ is the axis of joint $j$ expressed in base coordinates, $\mathbf{p}_{j-1}$ the position of joint $j$ origin, and $\mathbf{p}_e$ the end‚Äëeffector position.

B.3 Dynamics of Free‚ÄëFloating Space Robot

Let the system consist of a spacecraft base (body 0) and two arms each with 7 links. The total kinetic energy is:

T = \frac{1}{2} \dot{\mathbf{X}}^T \mathcal{M}(\mathbf{X}) \dot{\mathbf{X}},

where $\mathbf{X} \in \mathbb{R}^{6 + 14}$ includes base pose and joint angles. Due to free‚Äëfloating condition (no external forces, assuming zero initial momentum), the system's linear and angular momentum are conserved. This allows reduction of the dynamics.

Define the virtual manipulator (VM) approach: the end‚Äëeffector position relative to an inertial frame can be expressed as:

\mathbf{p}_e = \mathbf{p}_0 + \mathbf{r}_0 + \sum_{j=1}^n \mathbf{a}_j,

where $\mathbf{p}_0$ is base CM position, $\mathbf{r}_0$ is a fixed vector from base CM to first joint, and $\mathbf{a}_j$ are vectors along links. Because the base can move, the VM concept introduces a virtual base that is fixed in inertial space and a virtual manipulator with modified link lengths such that its kinematics match the real end‚Äëeffector motion under momentum conservation. See [Dubowsky & Papadopoulos, 1993] for details.

The reduced dynamics can be written as:

M_r(\mathbf{q}) \ddot{\mathbf{q}} + C_r(\mathbf{q},\dot{\mathbf{q}}) \dot{\mathbf{q}} = \boldsymbol{\tau} + J_r^T \mathbf{F}_{\text{ext}},

where $M_r$ is the reduced mass matrix (size $14 \times 14$), $C_r$ Coriolis terms, and $J_r$ the reduced Jacobian relating joint velocities to end‚Äëeffector velocity in inertial frame (but with base motion accounted). This form allows us to use standard robot control algorithms.

B.4 Redundancy Resolution

For a 7‚ÄëDOF arm, the null space of $J$ has dimension 1. The general solution for joint velocities given desired end‚Äëeffector velocity $\dot{\mathbf{x}}_{\text{des}}$ is:

\dot{\mathbf{q}} = J^+ \dot{\mathbf{x}}_{\text{des}} + (I - J^+ J) \mathbf{z},

where $J^+$ is the pseudoinverse and $\mathbf{z}$ an arbitrary vector. We choose $\mathbf{z} = k \nabla H(\mathbf{q})$ to optimize a secondary objective, such as:

¬∑ Joint limit avoidance: $H_{\text{lim}}(\mathbf{q}) = \sum_i \left( \frac{q_i - q_{i,\text{mid}}}{q_{i,\text{max}} - q_{i,\text{min}}} \right)^2$.
¬∑ Singularity avoidance: $H_{\text{sing}}(\mathbf{q}) = 1 / \det(J J^T)$ (or manipulability measure).

The gradient $\nabla H$ is projected into null space to move joints without affecting the end‚Äëeffector motion.

---

Appendix C: Clohessy‚ÄëWiltshire Equations and Relative Motion

C.1 Derivation of CW Equations

Consider a target spacecraft in a circular orbit with angular velocity $n = \sqrt{\mu / a^3}$ (mean motion). Define the LVLH frame: $x$ radial (away from Earth), $y$ along‚Äëtrack (velocity direction), $z$ cross‚Äëtrack (orbit normal). The relative position of the servicer w.r.t. target is $\mathbf{r} = [x, y, z]^T$. The equations of relative motion, linearized about the target orbit, are:

\begin{aligned}
\ddot{x} - 2n \dot{y} - 3n^2 x &= a_x, \\
\ddot{y} + 2n \dot{x} &= a_y, \\
\ddot{z} + n^2 z &= a_z,
\end{aligned}

where $a_x, a_y, a_z$ are control accelerations. These are the CW equations.

C.2 State‚ÄëSpace Form

Define state vector $\mathbf{X} = [x, y, z, \dot{x}, \dot{y}, \dot{z}]^T$. Then:

\dot{\mathbf{X}} = A \mathbf{X} + B \mathbf{u},

with

A = 
\begin{bmatrix}
0 & 0 & 0 & 1 & 0 & 0 \\
0 & 0 & 0 & 0 & 1 & 0 \\
0 & 0 & 0 & 0 & 0 & 1 \\
3n^2 & 0 & 0 & 0 & 2n & 0 \\
0 & 0 & 0 & -2n & 0 & 0 \\
0 & 0 & -n^2 & 0 & 0 & 0
\end{bmatrix},
\quad
B = 
\begin{bmatrix}
0 & 0 & 0 \\
0 & 0 & 0 \\
0 & 0 & 0 \\
1 & 0 & 0 \\
0 & 1 & 0 \\
0 & 0 & 1
\end{bmatrix}.

C.3 Analytical Solution

For constant acceleration $\mathbf{u}$, the solution is:

\mathbf{X}(t) = \Phi(t) \mathbf{X}(0) + \int_0^t \Phi(t-\tau) B \mathbf{u} \, d\tau,

where $\Phi(t) = e^{At}$ is the state transition matrix, given by:

\Phi(t) = 
\begin{bmatrix}
4-3\cos nt & 0 & 0 & \frac{\sin nt}{n} & \frac{2(1-\cos nt)}{n} & 0 \\
6(\sin nt - nt) & 1 & 0 & \frac{2(\cos nt -1)}{n} & \frac{4\sin nt - 3nt}{n} & 0 \\
0 & 0 & \cos nt & 0 & 0 & \frac{\sin nt}{n} \\
3n\sin nt & 0 & 0 & \cos nt & 2\sin nt & 0 \\
6n(\cos nt -1) & 0 & 0 & -2\sin nt & 4\cos nt -3 & 0 \\
0 & 0 & -n\sin nt & 0 & 0 & \cos nt
\end{bmatrix}.

These equations are used for trajectory prediction and MPC design.

---

Appendix D: Symmetry Groups and Quotient Space Construction

D.1 Detailed Definition of Orbital Symmetry Group $G_{\text{orb}}$

The full orbital state includes:

¬∑ Servicer position $\mathbf{p}_s$, velocity $\mathbf{v}_s$, attitude quaternion $\mathbf{q}_s$, angular velocity $\boldsymbol{\omega}_s$ (6 + 3 + 3 + 3 = 15 DOF)
¬∑ Target position $\mathbf{p}_t$, velocity $\mathbf{v}_t$, attitude $\mathbf{q}_t$, angular velocity $\boldsymbol{\omega}_t$ (another 15 DOF)
¬∑ Joint angles of two arms ($14$ DOF)
¬∑ Environmental parameters: radiation flux $\Phi$, temperature $T$, etc.

Total dimension ~50.

Symmetry transformations:

1. Translational symmetry: Absolute positions are irrelevant; only relative position matters. Define $G_{\text{trans}}$ as the group of simultaneous translations of servicer and target: $(\mathbf{p}_s, \mathbf{p}_t) \mapsto (\mathbf{p}_s + \mathbf{d}, \mathbf{p}_t + \mathbf{d})$. This leaves relative position $\mathbf{r} = \mathbf{p}_s - \mathbf{p}_t$ unchanged, as well as velocities (since translation doesn't affect velocities). So the quotient by $G_{\text{trans}}$ eliminates absolute positions.
2. Rotational symmetry about orbital normal: In many orbital servicing scenarios, the direction of the orbital normal (z‚Äëaxis of LVLH) is fixed, but rotations about this axis (yaw) are symmetric if the target is axisymmetric or if the task is yaw‚Äëinvariant. We quantize yaw angle to 8 bins ($45^\circ$). Formally, let $\psi$ be the yaw angle of the servicer relative to target LVLH frame. $G_{\text{rot}}$ is the finite group of rotations by multiples of $45^\circ$ about the LVLH z‚Äëaxis. States with yaw differing by a multiple of $45^\circ$ are considered equivalent. This is a discrete quotient, not a continuous symmetry.
3. Temporal symmetry: Orbital dynamics are periodic with period $T_{\text{orb}}$. Therefore, states separated by integer multiples of $T_{\text{orb}}$ are equivalent if the mission phase (e.g., approaching, grappling) is the same. We discretize time modulo $T_{\text{orb}}$ into 8 bins. This is a quotient by the cyclic group $\mathbb{Z}_8$ acting as time shifts.
4. Scale symmetry: During approach, the dynamics are scale‚Äëinvariant in the sense that the CW equations are linear, but safety margins scale with distance. However, for the purpose of compressing the state space for reactive lookup, we bin the distance $r = \|\mathbf{r}\|$ into logarithmic bins: $r \in [2^{k-1} d_0, 2^k d_0)$ for $k = 0,\dots, K-1$ with $K=4$ (enough for approach phases). This is a quotient by scaling transformations, but only a discrete set.

Thus $G_{\text{orb}}$ is a product of these groups, and the quotient space $\mathcal{S}/G_{\text{orb}}$ has size $8 \times 8 \times 4 \times \text{(remaining continuous variables)}$? Actually we also compress continuous variables into bins; the final compression yields a finite set of equivalence classes. We choose to map each class to a 4‚Äëbit equivalence class hash, and we also keep 4 bits of instance‚Äëspecific information (e.g., target type) to distinguish within a class. So total 8 bits ‚Üí 256 entries.

D.2 Canonical Mapping Algorithm

Given a full state $s$, we compute its canonical representative as follows:

1. Relative position: Compute $\mathbf{r} = \mathbf{p}_s - \mathbf{p}_t$ (in target LVLH frame).
2. Yaw quantization: Let $\psi = \operatorname{atan2}(R_{21}, R_{11})$ where $R$ is the rotation matrix from servicer body to LVLH. Compute $\psi_{\text{bin}} = \lfloor (\psi + \pi/16) / (\pi/4) \rfloor \mod 8$. Set canonical yaw to $\psi_{\text{bin}} \cdot (\pi/4)$.
3. Orbital phase: Compute $\phi = (t \mod T_{\text{orb}}) / T_{\text{orb}}$, then $\phi_{\text{bin}} = \lfloor 8\phi \rfloor$.
4. Distance bin: Compute $d = \|\mathbf{r}\|$. If $d < d_{\text{grapple}}$, bin = 0 (grapple zone); else if $d < d_{\text{approach}}$, bin = 1; else if $d < d_{\text{far}}$, bin = 2; else bin = 3. More sophisticated logarithmic binning can be used: $k = \lfloor \log_2(d/d_0) \rfloor$, clamped to 0..3.
5. Equivalence class hash: Combine the four bin indices into a 4‚Äëbit hash via a mixing function (e.g., XOR with rotation). Then combine with a 4‚Äëbit instance ID (derived from target type, mission phase, etc.) to form an 8‚Äëbit key for the coordination table.

---

Appendix E: LTL Constraint Set and Semantics for Orbital Safety

E.1 Linear Temporal Logic (LTL) Syntax and Semantics

LTL formulas are built from atomic propositions $p \in AP$ using Boolean connectives ($\neg$, $\land$, $\lor$, $\rightarrow$) and temporal operators:

¬∑ $X\phi$ (next): $\phi$ holds in the next state.
¬∑ $G\phi$ (globally): $\phi$ holds now and forever.
¬∑ $F\phi$ (finally): $\phi$ holds now or at some future time.
¬∑ $\phi U \psi$ (until): $\phi$ holds until $\psi$ holds.

Semantics are defined over infinite sequences $\sigma = s_0, s_1, s_2, \dots$:

¬∑ $\sigma \models p$ iff $p$ true in $s_0$.
¬∑ $\sigma \models X\phi$ iff $\sigma^1 \models \phi$ where $\sigma^1 = s_1, s_2, \dots$.
¬∑ $\sigma \models G\phi$ iff for all $i \ge 0$, $\sigma^i \models \phi$.
¬∑ $\sigma \models F\phi$ iff exists $i \ge 0$ such that $\sigma^i \models \phi$.
¬∑ $\sigma \models \phi U \psi$ iff exists $i \ge 0$ such that $\sigma^i \models \psi$ and for all $0 \le j < i$, $\sigma^j \models \phi$.

E.2 Orbital Atomic Propositions

We define atomic propositions based on state variables:

Proposition Meaning Definition
$\text{safe\_dist}$ Distance to target > threshold $\|\mathbf{r}\| > d_{\min}$
$\text{in\_corridor}$ Approach angle within limits $\theta_{\text{approach}} \in [\theta_{\min}, \theta_{\max}]$
$\text{force\_ok}$ Contact force below limit $\|\mathbf{F}_{\text{contact}}\| < F_{\max}$
$\text{torque\_ok}$ Contact torque below limit $\|\boldsymbol{\tau}_{\text{contact}}\| < \tau_{\max}$
$\text{fuel\_ok}$ Fuel remaining > threshold $m_{\text{fuel}} > m_{\min}$
$\text{comm\_ok}$ Communication link active $\text{link\_quality} > \text{threshold}$
$\text{ground\_ack}$ Acknowledgment received from ground Boolean flag

E.3 Safety Constraints as LTL Formulas

1. Collision avoidance:
   \phi_{\text{coll}} = G(\text{safe\_dist})
2. Approach corridor:
   \phi_{\text{corr}} = G(\text{in\_corridor})
3. Force/torque limits:
   \phi_{\text{force}} = G(\text{force\_ok} \land \text{torque\_ok})
4. Fuel management:
   \phi_{\text{fuel}} = G(\text{fuel\_ok})
5. Communication liveness (ensure ground contact within 300 s):
   \phi_{\text{comm}} = G(\text{comm\_ok} \rightarrow F_{\le 300} \text{ground\_ack})
   where $F_{\le T}$ is bounded finally.

E.4 Constraint Footprints

The footprint $F(\phi)$ is the set of state variables appearing in atomic propositions of $\phi$. For $\phi_{\text{coll}}$, footprint includes relative position $\mathbf{r}$. For $\phi_{\text{force}}$, includes force/torque sensor readings. This is used for Delta‚ÄëLTL.

---

Appendix F: Delta‚ÄëLTL Verification Algorithm

F.1 Algorithm Pseudocode

```
function verify_adaptation(s, Œî, Œ¶, cache):
    // s: current state
    // Œî: adaptation delta (partial map from variables to new values)
    // Œ¶: set of constraints with footprints
    // cache: verification cache (maps (œÜ, s) to result)
    
    D = domain(Œî)
    affected = { œÜ ‚àà Œ¶ | F(œÜ) ‚à© D ‚â† ‚àÖ }
    unaffected = Œ¶ \ affected
    
    results = {}
    
    // Unaffected constraints: retrieve from cache if possible
    for œÜ in unaffected:
        if cache.contains(œÜ, s):
            results[œÜ] = cache.get(œÜ, s)
        else:
            // For unaffected, s satisfies œÜ by induction hypothesis
            // but we may still need to check if Œî affects them via Lipschitz? 
            // As argued earlier, if footprint disjoint, truth unchanged.
            results[œÜ] = true   // because s satisfied œÜ and variables unchanged
    
    // Affected constraints: re-evaluate on new state s' = s ‚äï Œî
    s' = apply_delta(s, Œî)
    for œÜ in affected:
        if œÜ is safety (Gœà):
            // Evaluate œà on s'
            results[œÜ] = eval_œà(s')
        else if œÜ is liveness (Fœà) with progress measure Œº:
            // Check progress
            results[œÜ] = (Œº(s') < Œº(s)) or eval_œà(s')
        // Update cache
        cache.put(œÜ, s', results[œÜ])
    
    return all(results.values())
```

F.2 Complexity Analysis

Let $n = |\Phi|$, $d = |D|$, $a = |\Phi_{\text{aff}}|$. Finding affected constraints requires checking each œÜ's footprint against D, which is O(n) if footprints are stored as sets. But we can precompute a dependency graph mapping each variable to constraints that depend on it, then affected = union over v in D of deps(v). This yields O(d ¬∑ max_deps) time. Evaluation of each affected constraint costs O(1) typically (evaluating a simple predicate). Thus total O(d¬∑M + a) where M = max |deps(v)|. In practice, d is small (1‚Äì3), M is small (~5), a is small, so verification is very fast.

---

Appendix G: Proof‚ÄëCarrying Adaptation Inference Rules

G.1 Inference Rules

We define a set of inference rules for constructing safety proofs. Each rule has premises and a conclusion, and is sound with respect to the operational semantics.

Rule 1: DeltaSafety

```
Œî, s ‚ä®_Œ¥ œÜ   for all œÜ ‚àà Œ¶_aff
-------------------------------- (DeltaSafety)
ùí¶, Œ± ‚ä¢ Safe
```

where $\mathcal{K} = (s, \Phi)$ is the current context, $\alpha = (\Delta, \dots)$, and $‚ä®_Œ¥$ denotes that after applying Œî, œÜ holds.

Rule 2: Sandbox

```
SandboxSim(Œ±, N, H, Œµ) = no_violations
‚àÄœÜ ‚àà Œ¶, Lipschitz constant L_œÜ known
Œµ ‚â• max_œÜ L_œÜ ¬∑ H ¬∑ Œ¥_max   (Œ¥_max = max bound on state deviation)
-------------------------------- (Sandbox)
ùí¶, Œ± ‚ä¢ Safe
```

Here SandboxSim runs N Monte Carlo simulations over horizon H, with fidelity bound Œµ (max deviation from reality). The condition ensures that even if reality deviates by Œµ, the constraints remain satisfied due to margins.

Rule 3: ConservatismCompensation

```
Constraint œÜ violated in nominal state s ‚äï Œî
Conservatism multiplier Œ∫ provides margin M = Œ∫¬∑m‚ÇÄ
M ‚â• required_margin(œÜ, s ‚äï Œî)
-------------------------------- (ConservatismCompensation)
ùí¶, Œ± ‚ä¢ Safe
```

where required_margin computes the additional margin needed to satisfy œÜ given the violation.

Rule 4: SymmetryPreservation

```
s‚ÇÅ ‚àº_G s‚ÇÇ under orbital symmetry group G
œÜ is G-invariant
œÜ holds for canonical representative can(s‚ÇÅ)
-------------------------------- (SymmetryPreservation)
œÜ holds for s‚ÇÅ and s‚ÇÇ
```

G.2 Proof Checker Specification

The proof checker is a small program that verifies proofs are well‚Äëformed and that each rule application is valid. It operates recursively on proof trees.

```
function check_proof(œÄ, ùí¶, Œ±):
    if œÄ is leaf:
        return true if œÄ corresponds to an axiom (e.g., initial certified state)
    else:
        let rule = œÄ.rule
        let premises = œÄ.premises
        // Check that rule is applicable
        if rule == DeltaSafety:
            s = ùí¶.state
            s' = apply_delta(s, Œ±.Œî)
            for each œÜ in premises[0]:   // list of constraints
                if not eval(œÜ, s'):
                    return false
        else if rule == Sandbox:
            // Verify sandbox evidence matches premises
            if not verify_sandbox_evidence(œÄ.evidence):
                return false
            // Check Lipschitz condition
            for œÜ in ùí¶.constraints:
                if not (œÄ.Œµ ‚â• L_œÜ * œÄ.H * Œ¥_max):
                    return false
        else if rule == ConservatismCompensation:
            // Check margin condition
            if not (œÄ.M ‚â• œÄ.required_margin):
                return false
        // Recursively check subproofs
        for subœÄ in œÄ.subproofs:
            if not check_proof(subœÄ, ùí¶, Œ±):
                return false
        return true
```

The checker is implemented in a formally verified language (e.g., SPARK Ada) to eliminate implementation bugs.

---

Appendix H: Safety Ledger Data Structures and Cryptography

H.1 Certificate Structure

Each certificate $\mathcal{C}_i$ contains:

¬∑ prev_hash: SHA‚Äë256 hash of previous certificate.
¬∑ timestamp: UTC time of issuance.
¬∑ context_hash: Merkle root of the current safety context (compressed representation of state and constraints).
¬∑ adaptation_hash: Hash of the adaptation data (delta, added/removed constraints, policy update).
¬∑ proof_hash: Hash of the proof tree.
¬∑ orbital_metadata: Mission phase, target ID, orbital elements (optional).
¬∑ signature: ECDSA signature over all above fields using the private key of the signing authority (e.g., on‚Äëboard HSM).

H.2 Merkle Tree for Context

The context includes many elements (state variables, constraint set). To commit efficiently, we build a Merkle tree:

¬∑ Leaf: each state variable (quantized) or constraint identifier.
¬∑ Internal nodes: hash of concatenated children.
¬∑ Root: context_hash.

This allows proving inclusion of a specific element without revealing whole context.

H.3 Hash Chain Verification

To verify ledger integrity, we check for each i from 1 to k:

¬∑ $H(\mathcal{C}_{i-1}) == \mathcal{C}_i.\text{prev\_hash}$
¬∑ $\text{Verify}(\mathcal{C}_i.\text{signature}, \mathcal{C}_i.\text{data}, \text{public_key})$

Additionally, we may sample proofs to verify they are valid.

---

Appendix I: Novelty Detector Ensemble and Dempster‚ÄëShafer Fusion

I.1 Individual Detectors

We define six novelty detectors:

1. Dynamics residual:
   \eta_{\text{dyn}} = \sigma\left( \frac{\|\Delta \mathbf{v}_{\text{measured}} - \Delta \mathbf{v}_{\text{predicted}}\|}{\sigma_{\Delta v}} \right)
   where $\sigma$ is a sigmoid function squashing to [0,1], and $\sigma_{\Delta v}$ is a normalizing factor (expected residual under nominal conditions).
2. Geometry anomaly:
   \eta_{\text{geo}} = 1 - \text{IoU}(\text{observed point cloud}, \text{CAD model})
   where IoU is intersection‚Äëover‚Äëunion of occupied voxels.
3. Sensor fusion discrepancy:
   \eta_{\text{sens}} = \max_{i,j} \frac{\| \mathbf{m}_i - \mathbf{m}_j \|}{\sigma_{ij}}
   where $\mathbf{m}_i$ are measurements of the same quantity from different sensors, and $\sigma_{ij}$ is expected discrepancy.
4. Contact physics:
   \eta_{\text{phys}} = \frac{\| \mathbf{F}_{\text{measured}} - \mathbf{F}_{\text{predicted}} \|}{F_{\text{nominal}}}
   where $\mathbf{F}_{\text{predicted}}$ comes from a nominal contact model.
5. Radiation shift:
   \eta_{\text{rad}} = \frac{|\Phi_{\text{measured}} - \Phi_{\text{model}}|}{\sigma_\Phi}
6. Communication latency anomaly:
   \eta_{\text{comms}} = \frac{|t_{\text{roundtrip}} - t_{\text{expected}}|}{\sigma_t}

I.2 Dempster‚ÄëShafer Fusion

Let $\eta_i$ be the score from detector $i$. We interpret $\eta_i$ as mass assigned to "novel" and $1-\eta_i$ as mass assigned to "not novel". Dempster's rule combines two mass functions $m_1, m_2$:

(m_1 \oplus m_2)(A) = \frac{1}{1-K} \sum_{B \cap C = A} m_1(B) m_2(C),

where $K = \sum_{B \cap C = \emptyset} m_1(B) m_2(C)$ is the conflict.

For multiple detectors, we combine sequentially. The final novelty score $\nu$ is the mass assigned to "novel" after fusing all. The confidence $c$ is $1 - K$ after final fusion (or the mass assigned to the combined hypothesis? Typically confidence is related to lack of conflict). We define $c = 1 - \max_{i,j} |\eta_i - \eta_j|$, which approximates agreement.

The calibrated novelty is $\tilde{\nu} = \nu \cdot c$.

---

Appendix J: Lipschitz Constant Derivations for Constraints

For each safety constraint, we need a Lipschitz constant w.r.t. state changes to bound the effect of sandbox inaccuracy.

J.1 Collision Avoidance:
Constraint: $d = \|\mathbf{r}\| > d_{\min}$. The function $f(\mathbf{r}) = d$ is 1‚ÄëLipschitz: $|d_1 - d_2| \le \|\mathbf{r}_1 - \mathbf{r}_2\|$. So $L = 1$.

J.2 Approach Corridor:
Angle $\theta = \arccos\left( \frac{\mathbf{r} \cdot \mathbf{v}}{\|\mathbf{r}\|\|\mathbf{v}\|} \right)$. The Lipschitz constant depends on geometry but can be bounded by $L \le \frac{1}{\|\mathbf{r}\|_{\min}}$ plus other terms. In practice, we can compute a conservative bound based on worst‚Äëcase scenario.

J.3 Force/Torque Limits:
Contact force model may have Lipschitz constant related to stiffness. For a linear spring model, force is proportional to displacement, so $L = k$ (stiffness). We can bound $k$ by maximum expected stiffness of materials.

J.4 Fuel Limit:
Fuel consumption rate is Lipschitz in throttle command; with bounds on throttle, we can compute $L$.

For sandbox margin analysis, we need the maximum over constraints of $L_\phi \cdot H \cdot \varepsilon$, where $\varepsilon$ is sandbox fidelity bound.

---

Appendix K: Mii Framework Categorical Details Applied to Orbital Context

K.1 Category Definitions

Category $\mathsf{CR}_{\text{orb}}$:

¬∑ Objects: $( \Pi, \Gamma, \tau, \mathcal{W} )$ where $\Pi$ is a set of LTL formulas (constraints and goals), $\Gamma$ is mission context (target orbit, fuel, etc.), $\tau$ is a reasoning trace (list of deductions), $\mathcal{W} \in [0,1]^{|\Pi|}$ are attention weights.
¬∑ Morphisms: $f: (\Pi,\Gamma,\tau,\mathcal{W}) \to (\Pi',\Gamma',\tau',\mathcal{W}')$ consist of:
  ¬∑ A mapping $\phi: \Pi \to \Pi'$ (constraint refinement/abstraction)
  ¬∑ A mapping $\gamma: \Gamma \to \Gamma'$ (context update)
  ¬∑ A monotonic map on traces (extending trace)
  ¬∑ A weight adjustment respecting some constraints (e.g., sum of weights preserved).

Category $\mathsf{SP}_{\text{orb}}$:

¬∑ Objects: $(\xi, \mathcal{G}, \mathcal{H}, \beta)$ where $\xi \in \mathbb{R}^d$ is a sensor embedding, $\mathcal{G}$ is an association graph (nodes = failure patterns, edges = correlations), $\mathcal{H}: \mathcal{S} \to \mathbb{R}^m$ is a heuristic policy (e.g., neural network), $\beta \in \mathbb{R}^k$ is a mission‚Äëphase priming vector.
¬∑ Morphisms: include updates to embedding, graph modifications, policy updates.

Category $\mathsf{Mii}_{\text{orb}}$:

¬∑ Objects: $(C, S, \mathcal{T}, \alpha, \beta, \gamma)$ with $C \in \mathsf{CR}_{\text{orb}}$, $S \in \mathsf{SP}_{\text{orb}}$, $\mathcal{T}$ a translation table mapping symbolic constraints to perceptual patterns, and $(\alpha,\beta,\gamma)$ balance weights.
¬∑ Morphisms: pairs of morphisms from $C$ and $S$ that are compatible with $\mathcal{T}$ and weight adjustments.

K.2 Adjoint Functors

$F_{\text{orb}}: \mathsf{CR}_{\text{orb}} \to \mathsf{Mii}_{\text{orb}}$:

¬∑ On objects: $F(C) = (C, S_0, \mathcal{T}_0, \alpha_0, \beta_0, \gamma_0)$ where $S_0$ is an initial perceptual state (e.g., zero embedding) and $\mathcal{T}_0$ is the trivial translation (each constraint maps to an empty pattern set).
¬∑ On morphisms: $F(f)$ extends $f$ to act on $C$ component and leaves $S_0$, $\mathcal{T}_0$ unchanged (since they are initial).

$G_{\text{orb}}: \mathsf{Mii}_{\text{orb}} \to \mathsf{CR}_{\text{orb}}$:

¬∑ On objects: $G(C,S,\mathcal{T},\alpha,\beta,\gamma) = C$.
¬∑ On morphisms: projection onto the $C$ component.

The adjunction $F \dashv G$ is established by the natural isomorphism:

\hom_{\mathsf{Mii}}(F(C), (C',S',\mathcal{T}',\alpha',\beta',\gamma')) \cong \hom_{\mathsf{CR}}(C, C').

Given a morphism $h: C \to C'$, we can define $\tilde{h}: F(C) \to (C',S',\mathcal{T}',\alpha',\beta',\gamma')$ as $h$ on $C$ and the unique morphism from the initial $S_0$, $\mathcal{T}_0$ to $S'$, $\mathcal{T}'$ (if such exists). In our concrete setting, $S_0$ may not be initial; we may need to define a canonical map based on $\mathcal{T}'$ that extracts patterns from $S'$ corresponding to constraints in $C'$. This is where the "translation table" comes in: it links symbols to patterns, so we can map from $C'$ to $S'$ via $\mathcal{T}'$. The details are intricate but can be made rigorous.

K.3 Monad and Fixed Point

The composition $T = G \circ F$ is a monad on $\mathsf{CR}_{\text{orb}}$. Its algebras correspond to conscious states that are "self‚Äëaware" via the meta layer. The fixed point of $T$ (if it exists) represents a state where further meta‚Äëreflection yields no change‚Äîi.e., the system has reached a stable understanding. In the context of novelty detection, this corresponds to convergence of the conservatism multiplier after repeated exposure to similar novel situations.

---

End of Appendices