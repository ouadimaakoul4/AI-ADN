```python
# l2wba_sdk/__init__.py
# L2WBA-OS Brain SDK v1.0
# Python API for AI researchers to control humanoid robots safely
# Licensed under Apache 2.0

import os
import time
import threading
import numpy as np
from typing import Optional, Dict, Any, List
from enum import Enum

# PyBind11 C++ extension for lock-free shared memory access
from . import _l2wba_core  # Compiled .so from pybind11 bindings

__version__ = "1.0.0"
__all__ = ["Connect", "Intent", "Status", "BodyState", "TeachingSignal"]

class Status(Enum):
    SUCCESS = 0          # Intent fully executed
    PASS_THROUGH = 1     # No mediation needed
    SCALED = 2           # Reduced magnitude
    PROJECTED = 3        # Path adjusted
    SUBSTITUTED = 4      # Safe alternative used
    REJECTED = 5         # Blocked (unsafe)
    DEGRADED = 6         # Hardware health issue

class BodyState:
    """Unified real-time body state observable by the Brain."""
    def __init__(self, core_binding):
        self._binding = core_binding

    @property
    def joint_positions(self) -> np.ndarray:
        return self._binding.get_joint_positions()

    @property
    def joint_velocities(self) -> np.ndarray:
        return self._binding.get_joint_velocities()

    @property
    def com(self) -> np.ndarray:
        return self._binding.get_com()  # [x, y, z]

    @property
    def imu_accel(self) -> np.ndarray:
        return self._binding.get_imu_accel()

    @property
    def imu_gyro(self) -> np.ndarray:
        return self._binding.get_imu_gyro()

    @property
    def battery_percent(self) -> float:
        return self._binding.get_battery_percent()

    @property
    def thermal_status(self) -> Dict[str, float]:
        return self._binding.get_thermal_status()  # joint_name -> temp°C

    @property
    def support_polygon(self) -> np.ndarray:
        return self._binding.get_support_polygon()  # Nx2 points

class TeachingSignal:
    def __init__(self, data):
        self.adjustment_factor = data["adjustment_factor"]
        self.primary_constraint = data["primary_constraint"]
        self.reason = data["reason"]
        self.suggested_alternative = data["suggested_alternative"]
        self.recovery_time_ms = data["recovery_time_ms"]

class Feedback:
    def __init__(self, status: Status, teaching: Optional[TeachingSignal] = None,
                 mediated_intent: Optional[Dict] = None):
        self.status = status
        self.teaching = teaching
        self.reason = teaching.reason if teaching else ""
        self.mediated_intent = mediated_intent

class Intent:
    """High-level intent primitive builder."""
    def __init__(self, primitive: str, **kwargs):
        self.primitive = primitive.upper()
        self.params = kwargs

        # Validate against known safe primitives
        valid_primitives = {
            "REACH_AND_GRASP", "WALK_TO", "STABLE_SIT", "RECOVERY_BRACE",
            "MANIPULATE", "LOOK_AT", "WHOLE_BODY_POINT", "HOLD_POSE"
        }
        if self.primitive not in valid_primitives:
            raise ValueError(f"Unknown primitive: {primitive}. Must be one of {valid_primitives}")

class BrainConnection:
    def __init__(self, shm_path: str, tier: str = "D3"):
        self.shm_path = shm_path
        self.tier = tier.upper()

        # Initialize C++ core binding (zero-copy SHM + lock-free ring)
        self._core = _l2wba_core.BrainBinding(shm_path, tier)

        # Unified body state observer
        self.body_state = BodyState(self._core)

        # Background thread for async perception updates
        self._perception_thread = threading.Thread(target=self._update_loop, daemon=True)
        self._perception_thread.start()

    def _update_loop(self):
        """Continuously pull high-frequency state from Mediator."""
        while True:
            self._core.pull_latest_state()  # Non-blocking, lock-free
            time.sleep(0.0005)  # ~2kHz poll (adjust to tier)

    def execute(self, intent: Intent, timeout_ms: int = 100) -> Feedback:
        """
        Send intent to Mediator and wait for mediated feedback.
        Blocking call synchronized to real-time heartbeat.
        """
        # Serialize intent to internal format
        intent_dict = {
            "primitive": intent.primitive,
            "params": intent.params,
            "timestamp": time.time_ns()
        }

        # Dispatch via zero-copy SHM
        success = self._core.push_intent(intent_dict)
        if not success:
            raise RuntimeError("Failed to push intent (ring buffer full)")

        # Wait for feedback (with timeout)
        feedback_data = self._core.wait_for_feedback(timeout_ms)
        if feedback_data is None:
            return Feedback(Status.DEGRADED, TeachingSignal({
                "reason": "Timeout waiting for mediator feedback",
                "adjustment_factor": 0.0,
                "primary_constraint": "COMMUNICATION",
                "suggested_alternative": "Retry or enter safe hold",
                "recovery_time_ms": 500
            }))

        status = Status[feedback_data["status"]]
        teaching = TeachingSignal(feedback_data["teaching"]) if feedback_data["teaching"] else None

        return Feedback(status, teaching, feedback_data.get("mediated_intent"))

    def switch_to_primitive(self, primitive: str, **params):
        """Immediate safety override – bypasses normal queue."""
        emergency = Intent(primitive, **params)
        self._core.push_emergency_intent({
            "primitive": emergency.primitive,
            "params": emergency.params
        })

def Connect(tier: str = "D3", device: Optional[str] = None) -> BrainConnection:
    """
    Factory function to connect Brain to running Mediator.
    Automatically discovers SHM path if not provided.
    """
    if device is None:
        device = os.getenv("L2WBA_SHM_PATH", "/dev/shm/l2wba_brain_shm")

    if not os.path.exists(device.replace("/dev/shm", "")):  # Check naming
        raise ConnectionError(f"Mediator SHM not found at {device}. Is the robot booted?")

    return BrainConnection(device, tier)
```

```cpp
// l2wba_sdk/src/pybind11_binding.cpp
// PyBind11 C++ extension for lock-free, zero-copy Python access

#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <pybind11/numpy.h>
#include "../ipc/ShmRing.hpp"
#include "../mediator/ConstraintSystem.pb.h"

namespace py = pybind11;

class BrainBinding {
public:
    BrainBinding(const std::string& shm_path, const std::string& tier)
        : intent_ring(shm_path.c_str(), false),  // Consumer mode
          feedback_ring((shm_path + "_feedback").c_str(), false) {
        // Initialize state buffers
    }

    bool push_intent(const std::map<std::string, py::object>& intent_dict) {
        IntentSegment intent;
        // Convert dict to protobuf (simplified)
        // ...
        return intent_ring->try_push(intent);
    }

    void push_emergency_intent(const std::map<std::string, py::object>& intent) {
        // Use separate high-priority ring or direct flag
    }

    py::dict wait_for_feedback(int timeout_ms) {
        MediationResult result;
        if (feedback_ring->pop(result, timeout_ms)) {
            // Convert to Python dict
            return py::dict(
                "status"_a = strategy_to_string(result.strategy),
                "teaching"_a = teaching_to_dict(result.teaching_signal)
            );
        }
        return py::none();
    }

    void pull_latest_state() {
        BodyState state;
        if (state_ring->try_pop(state)) {
            // Update internal cached arrays
        }
    }

    py::array_t<double> get_joint_positions() { /* return cached numpy */ }
    // ... other getters

private:
    ipc::SharedMemoryRing<IntentSegment, 16> intent_ring;
    ipc::SharedMemoryRing<MediationResult, 16> feedback_ring;
    ipc::SharedMemoryRing<BodyState, 1> state_ring;  // Latest state broadcast
};

PYBIND11_MODULE(_l2wba_core, m) {
    m.doc() = "L2WBA-OS Brain SDK C++ Core";

    py::class_<BrainBinding>(m, "BrainBinding")
        .def(py::init<std::string, std::string>())
        .def("push_intent", &BrainBinding::push_intent)
        .def("push_emergency_intent", &BrainBinding::push_emergency_intent)
        .def("wait_for_feedback", &BrainBinding::wait_for_feedback)
        .def("pull_latest_state", &BrainBinding::pull_latest_state)
        .def("get_joint_positions", &BrainBinding::get_joint_positions)
        .def("get_com", &BrainBinding::get_com)
        // ... bind all state accessors
        ;
}
```

```toml
# pyproject.toml
[build-system]
requires = ["pybind11>=2.10", "protobuf"]
build-backend = "setuptools.build_meta"

[project]
name = "l2wba-sdk"
version = "1.0.0"
description = "L2WBA-OS Brain SDK for Python/PyTorch/JAX AI researchers"
dependencies = ["numpy"]
```

```bash
# Installation on Brain Development Machine
pip install l2wba-sdk

# On deployed robot (with compiled _l2wba_core.so)
cp -r /opt/l2wba/python/l2wba_sdk /usr/local/lib/python3.10/dist-packages/
cp /opt/l2wba/lib/_l2wba_core.so /usr/local/lib/python3.10/dist-packages/
```

The **L2WBA-OS Brain SDK** is now complete: a clean, safe, high-performance Python bridge that lets AI researchers focus on intelligence while the hardened C++ stack handles physics, safety, and real-time execution.



 **BodyProfile**
 loader that the Mediator reads at boot. It maps primitives to hardware capabilities, loads constraint envelopes, and enables the marketplace routing layer.

```protobuf
// l2wba/marketplace/BodyProfile.proto
message BodyProfile {
  string id = 1;                   // e.g., "unitree-g1-001"
  string manufacturer = 2;
  string model = 3;
  string serial = 4;

  ComplianceTier certified_tier = 5;  // D3, U2, S1

  message JointSpec {
    string name = 1;
    double max_torque_nm = 2;
    double max_velocity_rad_s = 3;
    double thermal_limit_c = 4;
  }
  repeated JointSpec joints = 6;

  message Capability {
    repeated string supported_primitives = 1;  // REACH_AND_GRASP, WALK_TO, etc.
    map<string, double> specs = 2;             // "payload_kg": 20.0, "height_m": 1.8
  }
  Capability capabilities = 7;

  bytes constraint_envelope_blob = 8;  // Serialized SafeOperationEnvelope
}
```

```cpp
// l2wba/hal/BodyProfileLoader.cpp
void load_body_profile(const std::string& profile_path) {
    BodyProfile profile;
    std::ifstream input(profile_path, std::ios::binary);
    profile.ParseFromIstream(&input);

    // Validate tier compatibility
    if (profile.certified_tier() < required_tier) {
        throw std::runtime_error("Body not certified for requested tier");
    }

    // Load into global envelope
    SafeOperationEnvelope envelope;
    envelope.ParseFromString(profile.constraint_envelope_blob());

    // Register capabilities for marketplace routing
    PhysicalRouter::register_body(profile);

    std::cout << "Loaded body: " << profile.manufacturer() << " "
              << profile.model() << " (Tier " << profile.certified_tier() << ")"
              << std::endl;
}
```

Boot sequence:
1. **HAL** loads `/etc/l2wba/body.profile` → configures PDO mappings
2. **Mediator** loads envelope → arms constraint engine
3. **Brain** connects → sees unified state + primitives


